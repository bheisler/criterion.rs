<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Custom Measurements - Criterion.rs Documentation</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="User Guide and Other Prose Documentation For Criterion.rs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../criterion_rs.html"><strong aria-hidden="true">1.</strong> Criterion.rs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting_started.html"><strong aria-hidden="true">1.1.</strong> Getting Started</a></li></ol></li><li class="chapter-item expanded "><a href="../user_guide/user_guide.html"><strong aria-hidden="true">2.</strong> User Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../user_guide/migrating_from_libtest.html"><strong aria-hidden="true">2.1.</strong> Migrating from libtest</a></li><li class="chapter-item expanded "><a href="../user_guide/command_line_output.html"><strong aria-hidden="true">2.2.</strong> Command-Line Output</a></li><li class="chapter-item expanded "><a href="../user_guide/command_line_options.html"><strong aria-hidden="true">2.3.</strong> Command-Line Options</a></li><li class="chapter-item expanded "><a href="../user_guide/html_report.html"><strong aria-hidden="true">2.4.</strong> HTML Report</a></li><li class="chapter-item expanded "><a href="../user_guide/plots_and_graphs.html"><strong aria-hidden="true">2.5.</strong> Plots &amp; Graphs</a></li><li class="chapter-item expanded "><a href="../user_guide/benchmarking_with_inputs.html"><strong aria-hidden="true">2.6.</strong> Benchmarking With Inputs</a></li><li class="chapter-item expanded "><a href="../user_guide/advanced_configuration.html"><strong aria-hidden="true">2.7.</strong> Advanced Configuration</a></li><li class="chapter-item expanded "><a href="../user_guide/comparing_functions.html"><strong aria-hidden="true">2.8.</strong> Comparing Functions</a></li><li class="chapter-item expanded "><a href="../user_guide/csv_output.html"><strong aria-hidden="true">2.9.</strong> CSV Output</a></li><li class="chapter-item expanded "><a href="../user_guide/known_limitations.html"><strong aria-hidden="true">2.10.</strong> Known Limitations</a></li><li class="chapter-item expanded "><a href="../user_guide/bencher_compatibility.html"><strong aria-hidden="true">2.11.</strong> Bencher Compatibility Layer</a></li><li class="chapter-item expanded "><a href="../user_guide/timing_loops.html"><strong aria-hidden="true">2.12.</strong> Timing Loops</a></li><li class="chapter-item expanded "><a href="../user_guide/custom_measurements.html" class="active"><strong aria-hidden="true">2.13.</strong> Custom Measurements</a></li><li class="chapter-item expanded "><a href="../user_guide/profiling.html"><strong aria-hidden="true">2.14.</strong> Profiling</a></li><li class="chapter-item expanded "><a href="../user_guide/custom_test_framework.html"><strong aria-hidden="true">2.15.</strong> Custom Test Framework</a></li><li class="chapter-item expanded "><a href="../user_guide/benchmarking_async.html"><strong aria-hidden="true">2.16.</strong> Benchmarking async functions</a></li></ol></li><li class="chapter-item expanded "><a href="../cargo_criterion/cargo_criterion.html"><strong aria-hidden="true">3.</strong> cargo-criterion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cargo_criterion/configuring_cargo_criterion.html"><strong aria-hidden="true">3.1.</strong> Configuring cargo-criterion</a></li><li class="chapter-item expanded "><a href="../cargo_criterion/external_tools.html"><strong aria-hidden="true">3.2.</strong> External Tools</a></li></ol></li><li class="chapter-item expanded "><a href="../iai/iai.html"><strong aria-hidden="true">4.</strong> Iai</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../iai/getting_started.html"><strong aria-hidden="true">4.1.</strong> Getting Started with Iai</a></li><li class="chapter-item expanded "><a href="../iai/comparison.html"><strong aria-hidden="true">4.2.</strong> Comparison to Criterion.rs</a></li></ol></li><li class="chapter-item expanded "><a href="../analysis.html"><strong aria-hidden="true">5.</strong> Analysis Process</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">6.</strong> Frequently Asked Questions</a></li><li class="chapter-item expanded "><a href="../migrating_0_2_to_0_3.html"><strong aria-hidden="true">7.</strong> Migrating from 0.2.* to 0.3.*</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                            </div>

                    <h1 class="menu-title">Criterion.rs Documentation</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="custom-measurements"><a class="header" href="#custom-measurements">Custom Measurements</a></h1>
<p>By default, Criterion.rs measures the wall-clock time taken by the benchmarks. However, there are
many other ways to measure the performance of a function, such as hardware performance counters or
POSIX's CPU time. Since version 0.3.0, Criterion.rs has had support for plugging in alternate
timing measurements. This page details how to define and use these custom measurements.</p>
<p>Note that as of version 0.3.0, only timing measurements are supported, and only a single measurement
can be used for one benchmark. These restrictions may be lifted in future versions.</p>
<h3 id="defining-custom-measurements"><a class="header" href="#defining-custom-measurements">Defining Custom Measurements</a></h3>
<p>For developers who wish to use custom measurements provided by an existing crate, skip to 
<a href="#using-custom-measurements">&quot;Using Custom Measurements&quot;</a> below.</p>
<p>Custom measurements are defined by a pair of traits, both defined in <code>criterion::measurement</code>.</p>
<h4 id="measurement"><a class="header" href="#measurement">Measurement</a></h4>
<p>First, we'll look at the main trait, <code>Measurement</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Measurement {
    type Intermediate;
    type Value: MeasuredValue;

    fn start(&amp;self) -&gt; Self::Intermediate;
    fn end(&amp;self, i: Self::Intermediate) -&gt; Self::Value;

    fn add(&amp;self, v1: &amp;Self::Value, v2: &amp;Self::Value) -&gt; Self::Value;
    fn zero(&amp;self) -&gt; Self::Value;
    fn to_f64(&amp;self, val: &amp;Self::Value) -&gt; f64;

    fn formatter(&amp;self) -&gt; &amp;dyn ValueFormatter;
}
<span class="boring">}
</span></code></pre></pre>
<p>The most important methods here are <code>start</code> and <code>end</code> and their associated types, <code>Intermediate</code>
and <code>Value</code>. <code>start</code> is called to start a measurement and <code>end</code> is called to complete it. As an
example, the <code>start</code> method of the wall-clock time measurement returns the value of the system
clock at the moment that <code>start</code> is called. This starting time is then passed to the <code>end</code> function,
which reads the system clock again and calculates the elapsed time between the two calls. This
pattern - reading some system counter before and after the benchmark and reporting the difference - 
is a common way for code to measure performance.</p>
<p>The next two functions, <code>add</code> and <code>zero</code> are pretty simple; Criterion.rs sometimes needs to be able
to break up a sample into batches that are added together (eg. in <code>Bencher::iter_batched</code>) and so
we need to have a way to calculate the sum of the measurements for each batch to get the overall
value for the sample. </p>
<p><code>to_f64</code> is used to convert the measured value to an <code>f64</code> value so that Criterion can perform its
analysis. As of 0.3.0, only a single value can be returned for analysis per benchmark. Since <code>f64</code>
doesn't carry any unit information, the implementor should be careful to choose their units to avoid
having extremely large or extremely small values that may have floating-point precision issues. For
wall-clock time, we convert to nanoseconds.</p>
<p>Finally, we have <code>formatter</code>, which just returns a trait-object reference to a <code>ValueFormatter</code> 
(more on this later).</p>
<p>For our half-second measurement, this is all pretty straightforward; we're still measuring
wall-clock time so we can just use <code>Instant</code> and <code>Duration</code> like <code>WallTime</code> does:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Silly &quot;measurement&quot; that is really just wall-clock time reported in half-seconds.
struct HalfSeconds;
impl Measurement for HalfSeconds {
    type Intermediate = Instant;
    type Value = Duration;

    fn start(&amp;self) -&gt; Self::Intermediate {
        Instant::now()
    }
    fn end(&amp;self, i: Self::Intermediate) -&gt; Self::Value {
        i.elapsed()
    }
    fn add(&amp;self, v1: &amp;Self::Value, v2: &amp;Self::Value) -&gt; Self::Value {
        *v1 + *v2
    }
    fn zero(&amp;self) -&gt; Self::Value {
        Duration::from_secs(0)
    }
    fn to_f64(&amp;self, val: &amp;Self::Value) -&gt; f64 {
        let nanos = val.as_secs() * NANOS_PER_SEC + u64::from(val.subsec_nanos());
        nanos as f64
    }
    fn formatter(&amp;self) -&gt; &amp;dyn ValueFormatter {
        &amp;HalfSecFormatter
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="valueformatter"><a class="header" href="#valueformatter">ValueFormatter</a></h4>
<p>The next trait is <code>ValueFormatter</code>, which defines how a measurement is displayed to the user.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ValueFormatter {
    fn format_value(&amp;self, value: f64) -&gt; String {...}
    fn format_throughput(&amp;self, throughput: &amp;Throughput, value: f64) -&gt; String {...}
    fn scale_values(&amp;self, typical_value: f64, values: &amp;mut [f64]) -&gt; &amp;'static str;
    fn scale_throughputs(&amp;self, typical_value: f64, throughput: &amp;Throughput, values: &amp;mut [f64]) -&gt; &amp;'static str;
    fn scale_for_machines(&amp;self, values: &amp;mut [f64]) -&gt; &amp;'static str;
}
<span class="boring">}
</span></code></pre></pre>
<p>All of these functions accept a value to format in f64 form; the values passed in will be in the
same scale as the values returned from <code>to_f64</code>, but may not be the exact same values. That is, if
<code>to_f64</code> returns values scaled to &quot;thousands of cycles&quot;, the values passed to <code>format_value</code> and
the other functions will be in the same units, but may be different numbers (eg. the mean of all
sample times).</p>
<p>Implementors should try to format the values in a way that will make sense to humans. 
&quot;1,500,000 ns&quot; is needlessly confusing while &quot;1.5 ms&quot; is much clearer. If you can, try to use SI
prefixes to simplify the numbers. An easy way to do this is to have a series of conditionals like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if ns &lt; 1.0 {  // ns = time in nanoseconds per iteration
    format!(&quot;{:&gt;6} ps&quot;, ns * 1e3)
} else if ns &lt; 10f64.powi(3) {
    format!(&quot;{:&gt;6} ns&quot;, ns)
} else if ns &lt; 10f64.powi(6) {
    format!(&quot;{:&gt;6} us&quot;, ns / 1e3)
} else if ns &lt; 10f64.powi(9) {
    format!(&quot;{:&gt;6} ms&quot;, ns / 1e6)
} else {
    format!(&quot;{:&gt;6} s&quot;, ns / 1e9)
}
<span class="boring">}
</span></code></pre></pre>
<p>It's also a good idea to limit the amount of precision in floating-point output - after a few
digits the numbers don't matter much anymore but add a lot of visual noise and make the results
harder to interpret. For example, it's very unlikely that anyone cares about the difference between
<code>10.2896653s</code> and <code>10.2896654s</code> - it's much more salient that their function takes &quot;about 10.290
seconds per iteration&quot;.</p>
<p>With that out of the way, <code>format_value</code> is pretty straightforward. <code>format_throughput</code> is also not
too difficult; match on <code>Throughput::Bytes</code> or <code>Throughput::Elements</code> and generate an appropriate
description. For wall-clock time, that would likely take the form of &quot;bytes per second&quot;, but a
measurement that read CPU performance counters might want to display throughput in terms of &quot;cycles
per byte&quot;. Note that default implementations of <code>format_value</code> and <code>format_throughput</code> are provided
which use <code>scale_values</code> and <code>scale_throughputs</code>, but you can override them if you wish.</p>
<p><code>scale_values</code> is a bit more complex. This accepts a &quot;typical&quot; value chosen by Criterion.rs, and a
mutable slice of values to scale. This function should choose an appropriate unit based on the
typical value, and convert all values in the slice to that unit. It should also return a string
representing the chosen unit. So, for our wall-clock times where the measured values are in
nanoseconds, if we wanted to display plots in milliseconds we would multiply all of the input
values by <code>10.0f64.powi(-6)</code> and return <code>&quot;ms&quot;</code>, because multiplying a value in nanoseconds by 10^-6
gives a value in milliseconds. <code>scale_throughputs</code> does the same thing, only it converts a slice of
measured values to their corresponding scaled throughput values.</p>
<p><code>scale_for_machines</code> is similar to <code>scale_values</code>, except that it's used for generating
machine-readable outputs. It does not accept a typical value, because this function should always
return values in the same unit.</p>
<p>Our half-second measurement formatter thus looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HalfSecFormatter;
impl ValueFormatter for HalfSecFormatter {
    fn format_value(&amp;self, value: f64) -&gt; String {
        // The value will be in nanoseconds so we have to convert to half-seconds.
        format!(&quot;{} s/2&quot;, value * 2f64 * 10f64.powi(-9))
    }

    fn format_throughput(&amp;self, throughput: &amp;Throughput, value: f64) -&gt; String {
        match *throughput {
            Throughput::Bytes(bytes) =&gt; format!(
                &quot;{} b/s/2&quot;,
                f64::from(bytes) / (value * 2f64 * 10f64.powi(-9))
            ),
            Throughput::Elements(elems) =&gt; format!(
                &quot;{} elem/s/2&quot;,
                f64::from(elems) / (value * 2f64 * 10f64.powi(-9))
            ),
        }
    }

    fn scale_values(&amp;self, ns: f64, values: &amp;mut [f64]) -&gt; &amp;'static str {
        for val in values {
            *val *= 2f64 * 10f64.powi(-9);
        }

        &quot;s/2&quot;
    }

    fn scale_throughputs(
        &amp;self,
        _typical: f64,
        throughput: &amp;Throughput,
        values: &amp;mut [f64],
    ) -&gt; &amp;'static str {
        match *throughput {
            Throughput::Bytes(bytes) =&gt; {
                // Convert nanoseconds/iteration to bytes/half-second.
                for val in values {
                    *val = (bytes as f64) / (*val * 2f64 * 10f64.powi(-9))
                }

                &quot;b/s/2&quot;
            }
            Throughput::Elements(elems) =&gt; {
                for val in values {
                    *val = (elems as f64) / (*val * 2f64 * 10f64.powi(-9))
                }

                &quot;elem/s/2&quot;
            }
        }
    }

    fn scale_for_machines(&amp;self, values: &amp;mut [f64]) -&gt; &amp;'static str {
        // Convert values in nanoseconds to half-seconds.
        for val in values {
            *val *= 2f64 * 10f64.powi(-9);
        }

        &quot;s/2&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="using-custom-measurements"><a class="header" href="#using-custom-measurements">Using Custom Measurements</a></h3>
<p>Once you (or an external crate) have defined a custom measurement, using it is relatively easy.
You will need to override the <code>Criterion</code> struct (which defaults to <code>WallTime</code>) by providing your
own measurement using the <code>with_measurement</code> function and overriding the default <code>Criterion</code> object
configuration. Your benchmark functions will also have to declare the measurement type they work
with.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fibonacci_cycles(criterion: &amp;mut Criterion&lt;HalfSeconds&gt;) {
    // Use the criterion struct as normal here.
}

fn alternate_measurement() -&gt; Criterion&lt;HalfSeconds&gt; {
    Criterion::default().with_measurement(HalfSeconds)
}

criterion_group! {
    name = benches;
    config = alternate_measurement();
    targets = fibonacci_cycles
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../user_guide/timing_loops.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../user_guide/profiling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../user_guide/timing_loops.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../user_guide/profiling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
